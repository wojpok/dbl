import open /List
import open /Format

let print = (extern dbl_printStrLn : String -> Unit)

pub data Stream = { chrs : List Char, position : Int} 

method seek (stream : Stream) =
  match stream.chrs with
  | _ :: xs => Stream { chrs=xs, position=stream.position + 1}
  | _ => stream
  end

pub method toString (stream : Stream)
  = "Stream " + stream.position.format + " " + stream.chrs.format

pub data SP (E : effect) T = 
  { peek  : Unit ->[E] Option Char
  , seek  : Unit ->[E] Unit
  , eof   : Unit ->[E] Bool
  , pos   : Unit ->[E] Int
  , rev   : Stream ->[E] Unit
  , fail  : {type X} -> T ->[E] X
  , emit  : {type X} -> (Pair Int T) ->[E] X
  , flip  : Unit ->[E] Bool
  , catch : Unit ->[E] Option (Pair Int T)
  }

pub let runParser (chrs : String) =
  handler
    SP { rev = effect stream / r => fn _ => r () stream
       , eof = effect _ / r => 
          fn (s : Stream) => 
            match s.chrs with
            | [] => r True  s
            | _  => r False s
            end
       , peek = effect _ / r => 
          fn (s : Stream) =>
            match s.chrs with
            | x :: _ => r (Some x) s
            | _      => r  None    s
            end
       , seek = effect _ / r => fn s => r () s.seek
       , pos  = effect _ / r => fn s => r s.position s
       , fail = effect msg => fn s => 
          Left (s.position, msg)
       , emit = effect msg => fn s => Left msg
       , flip = effect _ / r => fn s => 
          match r True s with
          | Left (pos, msg) =>
            if s.position == pos then
              r False s
            else
              Left (pos, msg)
          | x => x
          end
       , catch = effect _ / r => fn s =>
          match r None s with
          | Left e => r (Some e) s
          | x => x
          end
       }
    return x => fn s => Right (s.position, x)
    finally c => c (Stream {chrs=chrs.toList, position=0})
  end

abstr data Parser T O = Parser of ({E} -> SP E T ->[E] O)

pub method runP (Parser f) p = f p

pub let empty = Parser (fn _ => ())

pub let delay (f : Unit ->> Parser _ _) = 
  Parser (fn p => f () >. runP p)

pub method map (Parser c) f = 
  Parser (fn (p : SP _ _) => f (c p))

pub method val (Parser c) v =
  Parser (fn (p : SP _ _) => let _ = c p in v)

# pub method bind (Parser c) (f : _ ->> Parser _ _) =
#   Parser (fn (p : SP _ _) => let val = c p in (f p >.runP p))


pub method msg (Parser c) m = 
  Parser (fn (p : SP _ _) => 
    match p.catch () with
    | None => c p
    | Some (pos', msg') =>
      let pos = p.pos () in
      if pos' > pos then
        p.emit (pos', msg')
      else
        p.fail m
    end)

pub let char (c : Char) =
  Parser (fn (p : SP _ _) =>
    match p.peek () with
    | Some c' =>
      if c == c' 
        then (p.seek (); c) 
        else p.fail "Invalid character. Expected \{c}"
    | None => p.fail "Unexpected EOF"
    end)

pub let isChar pred =
  Parser (fn (p : SP _ _) =>
    match p.peek () with
    | Some c' => 
      if pred c' 
        then (p.seek (); c') 
        else p.fail "Invalid character"
    | None => p.fail "Unexpected EOF"
    end)

let isWhite (c : Char) = (c == ' ' || c == '\n' || c == '\t')
let isLetter (c : Char) = ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')
let isDigit (c : Char) = ('0' <= c && c <= '9')

let soft {E} (f : SP E _ ->> _) (p : SP E _) =
  match p.catch () with
  | None => f p
  | Some (p', m) => p.emit (p.pos (), m)
  end

pub method soft (Parser f) = Parser (soft f)

pub method seq (Parser f) (Parser g) =
  Parser (fn p => let _ = f p in g p)

pub method before (Parser f) (Parser g) =
  Parser (fn p => let res = f p in let _ = g p in res)

pub method many (Parser f) =
  Parser (fn (p : SP _ _) =>
    let rec iter (xs : List _) =
      match p.flip () with
      | True => let elem = f p in iter (elem :: xs)
      | False => xs.rev
      end in
    iter [])

pub method many1 (Parser f) =
  Parser (fn (p : SP _ _) =>
    let head = f p in
    let tail = (Parser f).many.runP p in
    head :: tail)

pub method sepBy (valP : Parser _ _) (sepP : Parser _ _) =
  Parser (fn (p : SP _ _) =>
    if p.flip () then
     (let hd = valP.runP p in
      let xs = sepP.seq valP >.many >.runP p in
      hd :: xs)
    else
      [])

let readNumber xs = 
  let rec iter xs (acc : Int) = 
    match xs with
    | [] => acc
    | x :: xs => iter xs (acc * 10 + (x : Char).code - '0'.code)
    end
  in iter xs 0

pub method lexeme (v : Parser _ _) = v.before (isChar isWhite >.many)

pub let parseNumber = isChar isDigit >.many1 >.map readNumber

pub method or (Parser t1) (Parser t2) =
  Parser (fn (p : SP _ _) =>
    if p.flip () then
      t1 p
    else
      t2 p)

pub let or (Parser t1, Parser t2) =
  Parser (fn (p : SP _ _) => 
    if p.flip () then
      t1 p
    else
      t2 p)

pub let rec parseChoice (xs : List (Parser _ _)) =
  (Parser (fn (p : SP _ _) =>
  let rec iter (p : SP _ _) xs =
    match xs with
    | Parser trans :: xs =>
      if p.flip () then
        trans p
      else
        iter p xs
    | [] => p.fail "Choice fail"
  end in
  iter p xs) : Parser _ _)

pub let parseKeyword (kw : String) = 
  Parser (fn (p : SP _ _) =>
    let ~onError _ = p.fail "Empty kw" in
    let first = char (kw.get 0) >.runP p in
    let wrd = isChar isLetter >.many >.runP p in
    if charListToStr ([first] + wrd) == kw then
      kw
    else
      p.fail "Expected \{kw | StringFmt {escape=False}}")
