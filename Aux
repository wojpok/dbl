


let evalTest {~prefix, ~print} (succ, fail) (tc : TestCase) =
  if tc.runTest then (1+succ, fail) else (succ, 1+fail)

rec
  {##
    Runs Tests associated with suite,
    then runs sub-suite
    Returns True if all tests and sub-suite passed, False otherwise
  ##}
  method runSuite {~prefix : List String, ~print} (suite : TestSuite) =
    suite.printTestsPreamble;
    let ~prefix = suite.name :: ~prefix in
    let ~print s = ~print ("  " + s) in
    let allTestsPassed =
      match listRev suite.tests.get with
      | []    => suite.reportNoTests; True
      | tests =>
        let testResults = listFold evalTest (0, 0) tests in
        printTestsResult testResults
      end
    let subsuitesPassed =
      match listRev suite.suites.get with
      | []     => suite.reportNoSubsuites; True
      | suites =>
        suite.printSuitesPreamble;
        let suiteResults =
          listFold evalSuite (0, 0) suites in
        suite.printSubSuitesResult suiteResults
      end
    in allTestsPassed && subsuitesPassed


  let evalSuite {~print, ~prefix} (succ, fail) (suite : TestSuite) =
    if suite.runSuite then
      (succ+1, fail)
    else
      (succ, fail+1)
end

{# ========================================================================= #}
{# MainTestRunner #}


data MainTestRunner = {suites : Ref IO (List TestSuite)}

let mainTestRunner = MainTestRunner {suites = ioMut.ref []}

method runAllTests (MainTestRunner {suites}) =
  let (_, fail) = listFold (evalSuite) (0, 0) (listRev suites.get) in
  printLn ();
  printStrLn "Failed tests info";
  let printFiledTest (TestResult {prefix, errors, name}) =
    printLn ();
    let _ = listIter (fn (s : String) => printStr "\{s}/") (listRev prefix) in 
    printStrLn "`\{name}`:";
    listIter (printErrorInfo) (listRev errors)
  in
  listIter printFiledTest (listRev failedTests.get)
  # if fail == 0 then ()
  # {# TODO : Change this to normal print + exit #}
  # else runtimeError "[====] Test Environment Failed"

{##
  If this file is imported, all registered tests will be run after program
  finishes
##}
handle _ = ()
  return _ =>
    {# TODO : Implement some sort of argument parsing,
              and tests-to-run selection #}
    {# TODO : When attributes are implemented, add them here #}
    let _ = mainTestRunner.runAllTests in ()
  finally _ => ()

method addTest (TestSuite {tests}) tc =
  tests := tc :: tests.get

method addSuite (MainTestRunner {suites}) suite =
  suites := suite :: suites.get

method addSuite (TestSuite {suites}) suite =
  suites := suite :: suites.get

{# ========================================================================= #}
{# Registering tests #}

{## This function wraps test body, handling test arbiter effect ##}
let constructTest name line file
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  let body () =
    handle ~testArbiter / F with testArbiterHandler in
    {# TODO : Add measuring execution time #}
    f ()
  in TestCase {name, line, file, body}


pub method addTest
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) testName
    (f : {E, ~testArbiter : TestArbiter E} ->
      Unit ->[E, IO] Unit) =
  suite.addTest (constructTest testName line file f)

pub let createTestSuite {~__line__ = line, ~__file__ = file} name =
  let suites = ioMut.ref []
  let tests = ioMut.ref []
  let suite = TestSuite {name, file, line, tests, suites} in
  mainTestRunner.addSuite suite;
  suite

pub method addSuite
    {~__line__ = line, ~__file__ = file}
    (suite : TestSuite) name =
  let suites = ioMut.ref []
  let tests = ioMut.ref [] in
  let suite' = TestSuite {name, file, line, tests, suites} in
  suite.addSuite suite';
  suite'

{# ========================================================================= #}
{# Assertion and Expectation Interface #}


{##
  Asserts that given value if False
 ##}
pub let assertFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  assertTrue
    {msg=msg.unwrapOr "Assertion Failed: Expected to be false"} (not cond)


{##
  Asserts that given function will call ~onError method.
 ##}
pub let assertCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertTrue
    {msg = "Assertion Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Asserts that given function will not call ~onError method.
 ##}
pub let assertDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _ ) =
  assertFalse
    {msg = "Assertion Failed: Expected function to not call on error implicit"}
    (callsOnError f)


{##
  Expects that given value is True.
 ##}
pub let expectTrue
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  if cond then
    ()
  else
    ~testArbiter.fail
      (ErrorInfo {line= ~__line__, file= ~__file__, errorType=Expectation
        , msg=msg.unwrapOr "Expectation Failed: Expected to be true"})

{##
  Expects that given value if False
 ##}
pub let expectFalse
    {~__line__, ~__file__, ~testArbiter : TestArbiter _, ?msg : String}
    cond =
  expectTrue
    {msg=msg.unwrapOr "Expectation Failed: Expected to be false"}
    (not cond)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
 ##}
pub let expectEq 
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    { msg = "Expectation Failed: Expected values to be equal"}
    (expected.equal actual)

{##
  Expects that 2 values are equal, according to first value's `equal` method.
  Default error message is generated using format methods.
 ##}
pub let expectEqF
    { ~__line__
    , ~__file__
    , ~testArbiter : TestArbiter _
    , ?msg : String
    , X : type
    , Y : type
    , method toString : X ->> String
    , method toString : Y ->> String
    , method equal : X ->> Y ->> Bool } 
    (expected : X) (actual : Y) =
  expectTrue
    {msg =
      "Expectation Failed: Expected\n\t\{expected}\n\t\{actual}\nto be equal"}
    (expected.equal actual)

let callsOnError (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  handle
    ~onError = effect _ => True
    return _ => False
  in f ()

{##
  Expects that given function will call ~onError method.
 ##}
pub let expectCallsOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  expectTrue
    {msg = "Expectation Failed: Expected function to call on error implicit"}
    (callsOnError f)

{##
  Expects that given function will not call ~onError method.
 ##}
pub let expectDoesNotCallOnError
    { ~__line__
    , ~__file__
    , ~testArbiter
    , ?msg : String }
    (f : {E, ~onError : _ ->[E] _} -> Unit ->[E] _) =
  expectFalse
    {msg =
      "Expectation Failed: Expected function to not call on error implicit"}
    (callsOnError f)