import Core
import /Test
import /List

pub type Doc = Core.ODoc

pub let (text : String -> Doc) = Core.text

pub let (empty : Doc) = Core.emptyDoc

pub let (flush : Doc -> Doc) = fn (d : Doc) => d.flush

pub let (char : Char -> Doc) = fn (c : Char) => text (charListToStr [c])

pub method flush = flush

pub let (shift : Doc -> Doc) = fn (d : Doc) => d.shift

pub method shift = shift

pub let (reset : Doc -> Doc) = fn (d : Doc) => d.reset

pub method reset = reset

pub let (<>) (d1 : Doc) (d2 : Doc) = d1.combine d2

pub let ($$) (d1 : Doc) (d2 : Doc) = d1.flush.combine d2

pub let hangWith (sep : String) (n : Int) (x : Doc) (y : Doc) =
  (Core.groupingBy sep [(0, x), (n, y)] : Doc)

pub let (hang : Int -> Doc -> Doc -> Doc) = hangWith " "

pub let (cat : List Doc ->[] Doc) =
  fn xs => Core.groupingBy "" (List.map (fn d => (0, d)) xs)

pub let encloseSep (left : Doc) (right : Doc) (sep : Doc) (ds : List Doc) =
  match ds with
  | [] => left
  | [x] => left <> x
  | d :: ds =>
    cat ((left <> d) :: List.map (fn d => sep <> d) ds)
  end <> right

pub let (list : List Doc ->[] Doc) = encloseSep (text "[") (text "]") (text ",")
pub let (tupled : List Doc ->[] Doc) = encloseSep (text "(") (text ")") (text ",")
pub let (semibraced : List Doc ->[] Doc) = encloseSep (text "{") (text "}") (text ";")

pub let (<+>) d1 d2 = d1 <> text " " <> d2

pub let (</>) d1 d2 = hang 0 d1 d2

pub let enclose l r d = l <> r <> d

pub let quite = enclose (text "\"") (text "\"")

pub let sep xs = Core.groupingBy " " (List.map (fn d => (0, d)) xs)

pub let textFmt
  {X, XFmt, method format : {?fmt : XFmt} -> X ->> String }
  (x : X) = text x.format

pub let textFmtF
  {X, XFmt, method format : {?fmt : XFmt} -> X ->> String }
  (x : X) (f : XFmt) = text (x.format {fmt=f})

pub let generate {?width : Int} = Core.generate {width = width.unwrapOr 80}
