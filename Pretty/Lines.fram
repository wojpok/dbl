import open /Lazy
import /List
import open /Test
import Size

type SList = Size.SList

{##
  Data structure representing unformed lines to display
 ##}
data rec L =
  ## Line catenation
  | LCat of L, L
  ## Line prefixed with `n` spaces
  | LFill of Int, L
  ## Any string
  | LStr of String
  ## Empty line
  | LEmpty
  ## Singular shift, exact amount of spaces
  ## will be decided during generation
  | LShift of L
  ## Reset node, contains Shift List to allocate
  ## shifts during rendering
  | LReset of SList, L
  ## Multi level shift. Jumps to nth shift on stack
  ## and inserts `static` amount of spaces
  | LAlign of {nth : Int, static : Int}, L

method format {?fmt : Unit} (self : L) =
  let rec iter l xs = match l with
    | LCat l1 l2 => iter l1 (iter l2 xs)
    | LFill n l => "f\{n} " :: xs
    | LStr s => s :: xs
    | LEmpty => xs
    | LShift l => "&" :: (iter l xs)
    | LReset slist l => "*(" :: (iter l (") " :: xs))
    | LAlign {nth, static} l => "<\{nth}, \{static}> " :: iter l xs
    end
  in strListCat (iter self [])     

data Line = {fill : L, str : L}

method format {?fmt : Unit} (Line {fill, str}) =
  "Line {fill = \{fill}, line = \{str}}"

let emptyLine = Line {fill = LEmpty, str = LEmpty}

type Lines = List Line

method flush (lines : Lines) = lines + [emptyLine]

method shift (lines : Lines) =
  List.map (fn (Line {fill, str}) =>
    Line {fill = LShift fill, str = LShift str}) lines

method reset (lines : Lines) slist = 
  List.map (fn (Line {fill, str}) =>
    Line {fill = LReset slist fill, str = LReset slist str}) lines

method combine (xs : Lines) (ys : Lines) =
  let rec iter xs = match xs with
    | [] => ys
    | [Line {fill, str}] =>
      match ys with
      | [] => [Line {fill, str}]
      | Line {fill=fill', str=str'} :: ys =>
        Line {fill=LCat fill fill', str = LCat str str'}
          :: List.map (fn (y : Line) =>
            Line{fill = LCat fill y.fill, str=LCat fill y.str}) ys
      end
    | x :: xs => x :: iter xs
    end in
  iter xs

type LineState = Pair (Pair (Pair Int (List Int)) Int) Int

data State E =
  { put : LineState ->[E] Unit
  , get : Unit ->[E] LineState }

let stateH (w : Int) =
  handler
    State
      { put = effect s / r => fn _ => r () s
      , get = effect _ / r => fn s => r s s }
      return x => fn _ => x
      finally c => c (0, [w], 0, 0)
  end

method move {E} (st : State E) (w : Int) = 
  let (p, sh, x, l) = st.get () in
  st.put (p + w, sh, x, l)

method getShift {E} (st : State E) =
  let (p, sh, x, l) = st.get () in
  match sh with
  | [] => runtimeError "Empty shift state"
  | s :: sh =>
    assert (p <= s);
    let diff = s - p in
    st.put (s, sh, x + 1, s);
    diff
  end

method putShifts {E} (st : State E) (sl : SList) =
  let (p, sh, _, _) = st.get () in
  let rec iter (p : Int) sl = match sl with
    | Size.SLast _ tl => iter p tl
    | Size.SFix i => [i + p]
    | Size.SShift i _ tl => i + p :: iter (i + p) tl
    end in
  st.put (p, iter p sl, 0, p)

method getAlignment {E} (st : State E) (n : Int) (cst : Int) =
  let (p, sh, x, l) = st.get () in
  if x == n then
   (let p' = cst + l in
    st.put (p', sh, x, l);
    p' - p)
  else
    match List.drop (n - x) sh with
    | [] => impossible ()
    | s :: sh =>
      let p' = l + cst in
      st.put (p', sh, n, s);
      printStrLn "\{p'} \{s}::\{sh}";
      p' - p
    end

let rec genL {~h : State _} (self : L) = match self with
  | LEmpty => ""
  | LStr str => ~h.move str.length; str
  | LShift tl =>
    let s = ~h.getShift in
    mkStr " " s + genL tl
  | LReset sl tl =>
    let (_, sh, n, l) = ~h.get () in
    ~h.putShifts sl;
    let res = genL tl in
    let (p, _, _, _) = ~h. get () in
    ~h.put (p, sh, n, l);
    res
  | LFill i tl =>
      ~h.move i;
      mkStr " " i + genL tl
  | LCat l1 l2 => genL l1 + genL l2
  | LAlign {nth=n, static=cst} tl =>
    let s = ~h.getAlignment n cst in
    mkStr " " s + genL tl
  end

let unlines w (xs : Lines) =
  let strs = List.map (fn (x : Line) => handle ~h with stateH w in genL x.str) xs in
  let rec fold (xs : List String) = match xs with
    | [] => ""
    | x :: xs => x + "\n" + fold xs
    end in
  fold strs

pub type DocLines = Lazy [] Lines

pub method flush (lines : DocLines) =
  pureLazy (fn _ => lines.force.flush)

pub method reset (lines : DocLines) slist =
  pureLazy (fn _ => lines.force.reset slist)

pub method shift (lines : DocLines) =
  pureLazy (fn _ => lines.force.shift)

pub method combine (lines1 : DocLines) (lines2 : DocLines) =
  pureLazy (fn _ => lines1.force.combine lines2.force)

let _ = testSuite "Pretty/Lines" (fn _ => ())
