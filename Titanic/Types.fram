import /List

import open Width

rec
  pub data Doc = { tree : DocTree, width : Width }

  pub let doc tree width = Doc { tree, width }

  pub data DocTree =
    | DEmpty
    | DStr    of String
    | DShift  of Doc
    | DReset  of Doc
    | DSeq    of List Doc
    | DStack  of List Doc
    | DLayout of Int, Doc
    | DColor  of Color, Doc
    | DBox    of Doc
    | DFlex   of Int
    | DExtra  of {type X}, X, (Int -> Int -> X ->> CtxBox)

  pub data CtxBox = { lines : List Line
                    , fill  : Line 
                    , size  : Int 
                    }

  pub let ctxBox lines fill size = CtxBox { lines, fill, size }

  pub data Color =
    | Black
    | Red
    | Green
    | Yellow
    | Blue
    | Magenta
    | Cyan
    | White

  pub data Line =
    | LStr   of String
    | LChr   of Char
    | LConc  of Line, Line
    | LFill  of Int,  String
    | LEmpty
    | LColor of Color
    | LColorPop

  pub method toString (c : Color) = 
    match c with
    | Black => "Black"
    | Red   => "Red"
    | Green => "Green"
    | Yellow => "Yellow"
    | Blue  => "Blue"
    | Magenta => "Magenta"
    | Cyan  => "Cyan"
    | White => "White"
    end

  pub method toString (d : Doc) = 
    "(" + d.width.toString + " -> " + d.tree.toString + ")"

  pub method toString (dt : DocTree) = 
    match dt with
    | DEmpty => "Empty"
    | DStr str => "Str " + str
    | DShift doc => "&" + doc.toString
    | DReset doc => "*" + doc.toString
    | DSeq ds => "Seq " + List.foldRight (fn (e : Doc) a => e.toString + " " + a) ds ""
    | DStack ds => "Stack " + List.foldRight (fn (e : Doc) a => e.toString + " " + a) ds ""
    | DLayout n doc => "Layout " + n.toString + " " + doc.toString
    | DFlex n => "Flex " + n.toString
    | DBox d => "Box " + d.toString
    | _ => "?"
    end

  pub method toString {type X, method toString : X ->> String} (self : List X) =
    "[" + List.foldRight (fn (e : X) a => e.toString + ", " + a) self "" + "]"
    
end

