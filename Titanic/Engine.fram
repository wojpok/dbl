import /List

import open Types
import open Width
import open Lines
import open Combinators

data State E X = State of
  { get    : Unit ->[E] X
  , put    : X ->[E] Unit
  , update : {F} -> (X ->[E,F] X) ->[E,F] Unit
  }

parameter E_st
parameter ~st : State E_st _

let get x =
  let (State { get }) = ~st in
  get x

let put x =
  let (State { put }) = ~st in
  put x

let update f =
  let (State { update }) = ~st in
  update f

handle ~st =
  let get = effect x / r => fn s => r s  s
  let put = effect s / r => fn _ => r () s
  let update f = put (f (get ())) in
    State { get, put, update }
  return  x => fn _ => x
  finally c => c ((0, 0), ([] : List Step), ([] : List Int))

let getFlex () = 
  let (fl, _, _) = get ()
  in fl

let putFlex fl =
  let (_, sts, shs) = get ()
  in put (fl, sts, shs)

let getSteps () = 
  let (_, sts, _) = get ()
  in sts

let putSteps sts =
  let (fl, _, shs) = get ()
  in put (fl, sts, shs)

let getShifts () = 
  let (_, _, shs) = get ()
  in shs

let putShifts shs =
  let (fl, sts, _) = get ()
  in put (fl, sts, shs)

let bt f () = 
  let st = get ()
  let res = f ()
  let _ = put st
  in res

pub let exampleComputation () = 
  let _ = putFlex (0, 3)
  let recComp () = 
    (let _ = put ((0, 0), [], [])
     in 7)
  let res = bt recComp ()
  let fl = getFlex ()
  in (snd fl) * res

let eLine n = LFill n " "

let qCtx lines len = ctxBox lines (eLine len) len

let nextShift () = 
  match getShifts () with
  | x :: _ => x
  | _ => 0
  end

let updateSpread (offset : Int) (step : Step) =
  let ns = nextShift () in
  putFlex (populateSpread (ns - offset) step)

let assignSpread (n : Int) = 
  let spread = getFlex ()
  let (size, ns) = assignSpreadState n spread
  let _ = putFlex ns
  in size

let popShift () = 
  match getShifts () with
  | x :: y :: tl => 
    let _ = putShifts (x + y :: tl) 
    in x
  | [res] => res
  | [] => 0
  end

let popSpread nextShift size = 
  match getSteps () with
  | [] => putFlex (0, 0)
  | [x] => putFlex (snd (assignSpreadState size x.toPair))
  | x :: xs => 
    putSteps xs;
    putFlex (snd (assignSpreadState nextShift x.toPair))
  end

let rec toLines (size : Int) (offset : Int) (d : Doc) =
  match d.tree with
  | DEmpty => ctxBox [] LEmpty 0
  | DStr str => qCtx [LStr str] str.length
  | DColor col doc =>
    let ctx = toLines size offset doc in 
    ctxBox 
      (List.map (fn (l : Line) => LColor col >. concat l >. concat LColorPop) ctx.lines)
      ctx.fill
      ctx.size
  | DSeq ds =>
    let rec iter size off ds = 
      match ds with
      | [] => ctxBox [] LEmpty 0
      | d :: ds =>
        let ctxHead = toLines size off d
        let ctxTail = iter (size - ctxHead.size) (off + ctxHead.size) ds
        let lines = linesFill (ctxHead.fill) (ctxHead.lines) (ctxTail.fill) (ctxTail.lines)
        in ctxBox lines (ctxHead.fill.concat ctxTail.fill) (ctxHead.size + ctxTail.size)
      end
    in iter size offset ds
  | DStack ds =>
    # let size' = assignSpread (d.width.singleStep.flex)
    let rec iter (ds : List Doc) =
      match ds with
      | [] => []
      | d :: ds =>
        let proc () =
          {# let _ = putSteps d.width.steps
          # let _ = updateSpread offset d.width.singleStep
          # let _ = 
          in #} toLines size offset d
        in bt proc () :: iter ds
      end
    let ctxs = iter ds
    let maxs = List.foldRight (fn (x : CtxBox) y => x.size.max y) ctxs 0
    let aligned = List.map (fn (ctx : CtxBox) => alignLines maxs ctx.size ctx.lines) ctxs
    in qCtx (List.concat aligned) maxs
  | DReset d =>
    let shifts = allocateShift AMFloat size d.width
    let recComp () =
      let _ = putSteps d.width.steps
      let _ = putShifts shifts
      let _ = updateSpread offset d.width.singleStep
      in toLines (List.foldLeft (+) 0 shifts) 0 d
    in bt recComp ()
  | DShift d =>
    let shift = popShift ()
    let nextShift = bt popShift () # TODO improve this ugly call
    let _ = popSpread (nextShift - shift - 1) size
    let missingShift = shift - offset
    let ctx = toLines (size - missingShift) (offset + missingShift) d
    let lines = linesFill (eLine missingShift) [] ctx.fill ctx.lines
    in qCtx lines (missingShift + ctx.size)
  | DLayout size doc => toLines size offset doc
  | DFlex n => 
    let s = assignSpread n in
    qCtx [LFill s " "] s
  | DBox doc =>
    let ctx = toLines (size - 2) (offset + 1) doc
    let w = ctx.size
    let mapped = List.map (fn (l : Line) => LStr "│" >. concat l >. concat (LStr "│")) ctx.lines
    let topLine    = LStr "╭" >. concat (LFill w "─") >. concat (LStr "╮")
    let bottomLine = LStr "╰" >. concat (LFill w "─") >. concat (LStr "╯")
    in qCtx ([topLine] + mapped + [bottomLine]) (w + 2)
  | _ => toLines 0 0 (doc DEmpty (fixedWidth 0))
  end

pub let showDoc (doc : Doc) =
  let width = doc.width.minWidth
  let ctx = toLines width 0 doc
  let str = reduceLines ctx.lines
  in printStrLn str

let _ = printStrLn (allocateShift AMFloat 27 (fixedWidth 18 >. shift >. addFixed 9)).toString
# let _ = let (x, y) = (populateSpread 20 (fixedWidth 8 >. addFlex 20 >. singleStep))
#         in printStrLn (x.toString + " " + y.toString)

pub let debugDoc (d : Doc) =
  let ident d = ppStr "  " <+> d
  let rec showWidth sh =
    match sh with
    | WShift s1 s2 tl => 
      ppShift (ppSeq [ppStr ("  Shift " + s1.toString + " " + s2.toString), showWidth tl])
    | WFixed s =>
      ppShift (ppStr ("  Fixed " + s.toString))
    end
  rec
    let showTree f tree =
      match tree with
      | DEmpty     => f (ppStr "Empty")
      | DColor c d => f (ppStr ("Color " + c.toString)) /+/ ident (showDoc d)
      | DBox d     => f (ppStr "Box") /+/ ident (showDoc d)
      | DStr s     => f (ppStr ("Str " + s))
      | DShift d   => f (ppStr "Shift") /+/ ident (showDoc d)
      | DReset d   => f (ppStr "Reset") /+/ ident (showDoc d)
      | DSeq ds    => ppStack (f (ppStr "Seq") :: List.map (fn x => ident (showDoc x)) ds)
      | DStack ds  => ppStack (f (ppStr "Stack") :: List.map (fn x => ident (showDoc x)) ds)
      | DFlex n    => f (ppStr ("Flex " + n.toString))
      | DLayout n d => f (ppStr ("Lay " + n.toString)) /+/ ident (showDoc d)
      | DExtra _ _ => f (ppStr "Extra")
      end
    let showDoc (d : Doc) =
      showTree (fn x => x <+> showWidth d.width) d.tree
  end
  in ppReset (showDoc d)

