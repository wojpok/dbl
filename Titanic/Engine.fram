import /List

import open Types
import open Width
import open Lines

data State E X = State of
  { get    : Unit ->[E] X
  , put    : X ->[E] Unit
  , update : {F} -> (X ->[E,F] X) ->[E,F] Unit
  }

parameter E_st
parameter ~st : State E_st _

let get x =
  let (State { get }) = ~st in
  get x

let put x =
  let (State { put }) = ~st in
  put x

let update f =
  let (State { update }) = ~st in
  update f

handle ~st =
  let get = effect x / r => fn s => r s  s
  let put = effect s / r => fn _ => r () s
  let update f = put (f (get ())) in
    State { get, put, update }
  return  x => fn _ => x
  finally c => c ((0, 0), ([] : List Step), ([] : List Int))

let getFlex () = 
  let (fl, _, _) = get ()
  in fl

let putFlex fl =
  let (_, sts, shs) = get ()
  in put (fl, sts, shs)

let getSteps () = 
  let (_, sts, _) = get ()
  in sts

let putSteps sts =
  let (fl, _, shs) = get ()
  in put (fl, sts, shs)

let getShifts () = 
  let (_, _, shs) = get ()
  in shs

let putShifts shs =
  let (fl, sts, _) = get ()
  in put (fl, sts, shs)

let bt f () = 
  let st = get ()
  let res = f ()
  let _ = put st
  in res

pub let exampleComputation () = 
  let _ = putFlex (0, 3)
  let recComp () = 
    (let _ = put ((0, 0), [], [])
     in 7)
  let res = bt recComp ()
  let fl = getFlex ()
  in (snd fl) * res

let eLine n = LFill n " "

let qCtx lines len = ctxBox lines (eLine len) len

let nextShift () = 
  match getShifts () with
  | x :: _ => x
  | _ => 0
  end

let updateSpread (offset : Int) (step : Step) =
  let ns = nextShift () in
  putFlex (populateSpread (ns - offset) step)

let assignSpread (n : Int) = 
  let spread = getFlex ()
  let (size, ns) = assignSpreadState n spread
  let _ = putFlex ns
  in size

let rec toLines (size : Int) (offset : Int) (d : Doc) =
  match d.tree with
  | DEmpty => ctxBox [] LEmpty 0
  | DStr str => qCtx [LStr str] str.length
  | DColor col doc =>
    let ctx = toLines size offset doc in 
    ctxBox 
      (List.map (fn (l : Line) => LColor col >. concat l >. concat LColorPop) ctx.lines)
      ctx.fill
      ctx.size
  | DSeq ds =>
    let rec iter size off ds = 
      match ds with
      | [] => ctxBox [] LEmpty 0
      | d :: ds =>
        let ctxHead = toLines size off d
        let ctxTail = iter (size - ctxHead.size) (off + ctxHead.size) ds
        let lines = linesFill (ctxHead.fill) (ctxHead.lines) (ctxTail.fill) (ctxTail.lines)
        in ctxBox lines (ctxHead.fill.concat ctxTail.fill) (ctxHead.size + ctxTail.size)
      end
    in iter size offset ds
  | DReset d =>
    let shifts = allocateShift AMFloat size d.width
    let recComp () =
      let _ = putSteps d.width.steps
      let _ = putShifts shifts
      let _ = updateSpread offset d.width.singleStep
      in toLines (List.foldLeft (+) 0 shifts) 0 d
    in bt recComp ()
  | DLayout size doc => toLines size offset doc
  | DFlex n => 
    let s = assignSpread n in
    qCtx [LFill s " "] s
  | _ => toLines 0 0 (doc DEmpty (fixedWidth 0))
  end

pub let showDoc (doc : Doc) =
  let width = doc.width.minWidth
  let ctx = toLines width 0 doc
  let str = reduceLines ctx.lines
  in printStrLn str

let _ = printStrLn (allocateShift AMFloat 10 (fixedWidth 6 >. addFlex 10)).toString

