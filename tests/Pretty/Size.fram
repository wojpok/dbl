import open /Test
import open /Pretty/Size

let _ =
  pub let suite = createTestSuite "Size" in
    let (<>)  (s : Size) = s.combine
    let ($$)  (s : Size) = s.flush.combine
    let ~onError () = runtimeError "" : Unit
    let (>+>) {~onError} (s : Size) = s.seq in

    let testCase = suite.addTest in
    let _ = 
      let testCase = suite.addSuite "emptySize" >.addTest in
        testCase "has 0 width" (fn _ =>
          assertEq emptySize.width (SLast {width=0} (SFix {width=0})));
        
        testCase "has 0 height" (fn () =>
          assertEq emptySize.height 0);
        () in
    
    let _ =
      let testCase = suite.addSuite "textSize" >.addTest in
        testCase "fix width" (fn () =>
          ["", "abc", "jak-to-jest-byc-skyba?"].iter (fn str =>
            assertEq (textSize str).width
              (SLast {width=str.length} (SFix {width=str.length}))));
          
        testCase "0 height" (fn () =>
          ["", "abc", "jak-to-jest-byc-skyba?"].iter (fn str =>
            assertEq (textSize str).height 0));
        () in

    let _ =
      let testCase = suite.addSuite "operator <>" >.addTest in
      testCase "identity" (fn () => 
        let t = textSize "abc" in
        assertEq t (t <> emptySize);
        assertEq t (emptySize <> t));
      
      testCase "simple text" (fn () => 
        let t = textSize "abc" <> textSize "def" in
        assertEq t.width (SLast {width=6} (SFix {width=6}));
        assertEq t.height 0);
      
      testCase "semigroup" (fn () =>
        let t1 = textSize "defghijk"
        let t2 = textSize "abc"
        let t3 = textSize "asdasd" in
        assertEq ((t1 <> t2) <> t3) (t1 <> (t2 <> t3)));
      () in

    testCase "`flush`" (fn () =>
      let t = textSize "abc" >. flush in
      assertEq t.height 1;
      assertEq t.width (SLast {width=0} (SFix {width=3})));

    let _ =
      let testCase = suite.addSuite "operator $$" >.addTest in
      testCase "1" (fn () =>
        let t = textSize "abc" $$ textSize "defghijk" in
        assertEq t.height 1;
        assertEq t.width (SLast {width=8} (SFix {width=8})));
      
      testCase "2" (fn () =>
        let t = textSize "defghijk" $$ textSize "abc" in
        log "height = \{t.height}";
        assertEq t.height 2;
        assertEq t.width (SLast {width=3} (SFix {width=8})));
    
      testCase "semigroup" (fn () =>
        let t1 = textSize "defghijk"
        let t2 = textSize "abc"
        let t3 = textSize "asdasd" in
        assertEq ((t1 $$ t2) $$ t3) (t1 $$ (t2 $$ t3)));
      () in
    
    testCase "`<>` `$$` semigroup" (fn () =>
      let t1 = textSize "aaaaaaaaaa" $$ textSize "aa"
      let t2 = textSize "bbb" $$ textSize "bbbbbb"
      let t3 = textSize "ccccccc" $$ textSize "cc" in
      assertEq ((t1 <> t2) <> t3) (t1 <> (t2 <> t3)));
    
    let _ =
      let testCase = suite.addSuite "shift" >.addTest in
        testCase "simple" (fn () =>
          let t1 = textSize "abc" >.shift in
          assertEq t1.height 1;
          assertEq t1.width
            (SShift {width=0, dangle=0} (SLast {width=3} (SFix {width=3}))));

        testCase "adds width" (fn () =>
          let t = textSize "abc" in
          assertEqF (t <> t.shift).width
            (SShift {width=3, dangle=3} (SLast {width=3} (SFix {width=3}))));

        testCase "aligns paraller structures" (fn () =>
          let t1 = textSize "aaaaa" <> (textSize "bb" >.shift)    <> (textSize "ccccc" >.shift)
          let t2 = textSize "aa"    <> (textSize "bbbbb" >.shift) <> (textSize "cc" >. shift) in
          assertEqF (t1 $$ t2).width
            (SShift {width=5, dangle=5} (SShift {width=5, dangle=5} (SLast {width=2} (SFix {width=5})))));
    
        () in
    
    let _ =
      let testCase = suite.addSuite "reset" >.addTest in
        testCase "identity over text" (fn () =>
          let t1 = textSize "abc" in
          assertEq t1 t1.reset);

        testCase "with `shift` fixes width" (fn () =>
          let t = textSize "abc" in
          assertEqF (t <> t.shift).reset.width (SLast {width=6} (SFix {width=6})));
      () in
    ()
    # testCase "`seq` simple docs" (fn {X, ~onError : Unit ->> X, ~testArbiter} () =>
    #   let t = textSize "abc" $$ textSize "d" in
    #   assertEqF (t >+> t).width (SLast {width=4} (SFix {width=6})));
    # 
    # testCase "`seq` shifted docs" (fn {X, ~onError : Unit ->> X, ~testArbiter} () =>
    #   let t = textSize "abc" $$ textSize "d" in
    #   let lt = t <> t.shift in
    #   assertEqF
    #     lt.width
    #     (SShift {dangle=3, width=1} (SLast {width = 1} (SFix {width = 3})));
    #   assertEqF
    #     (lt >+> t).width
    #     (SShift {dangle=3,width=1} (SLast {width=4} (SFix {width=6}))));
    # ()

let _ = createSuiteF "Size" (fn _ =>
    let (<>)  (s : Size) = s.combine
    let ($$)  (s : Size) = s.flush.combine
    let ~onError () = runtimeError "" : Unit
    let (>+>) {~onError} (s : Size) = s.seq in

    withSuiteF "emptySize" (fn _ =>
      testCaseF "has 0 width" (fn _ =>
        assertEq emptySize.width (SLast {width=0} (SFix {width=0})));
      
      testCaseF "has 0 height" (fn () =>
        assertEq emptySize.height 0);
      ());
    
      withSuiteF "textSize" (fn _ =>
        testCaseF "fix width" (fn () =>
          ["", "abc", "jak-to-jest-byc-skyba?"].iter (fn str =>
            assertEq (textSize str).width
              (SLast {width=str.length} (SFix {width=str.length}))));
          
        testCaseF "0 height" (fn () =>
          ["", "abc", "jak-to-jest-byc-skyba?"].iter (fn str =>
            assertEq (textSize str).height 0));
        ());

    withSuiteF "operator <>" (fn _ =>
      testCaseF "identity" (fn () => 
        let t = textSize "abc" in
        assertEq t (t <> emptySize);
        assertEq t (emptySize <> t));
      
      testCaseF "simple text" (fn () => 
        let t = textSize "abc" <> textSize "def" in
        assertEq t.width (SLast {width=6} (SFix {width=6}));
        assertEq t.height 0);
      
      testCaseF "semigroup" (fn () =>
        let t1 = textSize "defghijk"
        let t2 = textSize "abc"
        let t3 = textSize "asdasd" in
        assertEq ((t1 <> t2) <> t3) (t1 <> (t2 <> t3)));
      ());

    testCaseF "`flush`" (fn () =>
      let t = textSize "abc" >. flush in
      assertEq t.height 1;
      assertEq t.width (SLast {width=0} (SFix {width=3})));

    withSuiteF "operator $$" (fn _ =>
      testCaseF "1" (fn () =>
        let t = textSize "abc" $$ textSize "defghijk" in
        assertEq t.height 1;
        assertEq t.width (SLast {width=8} (SFix {width=8})));
      
      testCaseF "2" (fn () =>
        let t = textSize "defghijk" $$ textSize "abc" in
        log "height = \{t.height}";
        assertEq t.height 2;
        assertEq t.width (SLast {width=3} (SFix {width=8})));
    
      testCaseF "semigroup" (fn () =>
        let t1 = textSize "defghijk"
        let t2 = textSize "abc"
        let t3 = textSize "asdasd" in
        assertEq ((t1 $$ t2) $$ t3) (t1 $$ (t2 $$ t3)));
      ());
    
    testCaseF "`<>` `$$` semigroup" (fn () =>
      let t1 = textSize "aaaaaaaaaa" $$ textSize "aa"
      let t2 = textSize "bbb" $$ textSize "bbbbbb"
      let t3 = textSize "ccccccc" $$ textSize "cc" in
      assertEq ((t1 <> t2) <> t3) (t1 <> (t2 <> t3)));
    
    withSuiteF "shift" (fn _ =>
      testCaseF "simple" (fn () =>
        let t1 = textSize "abc" >.shift in
        assertEq t1.height 1;
        assertEq t1.width
          (SShift {width=0, dangle=0} (SLast {width=3} (SFix {width=3}))));

      testCaseF "adds width" (fn () =>
        let t = textSize "abc" in
        assertEqF (t <> t.shift).width
          (SShift {width=3, dangle=3} (SLast {width=3} (SFix {width=3}))));

      testCaseF "aligns paraller structures" (fn () =>
        let t1 = textSize "aaaaa" <> (textSize "bb" >.shift)    <> (textSize "ccccc" >.shift)
        let t2 = textSize "aa"    <> (textSize "bbbbb" >.shift) <> (textSize "cc" >. shift) in
        assertEqF (t1 $$ t2).width
          (SShift {width=5, dangle=5} (SShift {width=5, dangle=5} (SLast {width=2} (SFix {width=5})))));
      ());
    
      withSuiteF "reset" (fn _ =>
        testCaseF "identity over text" (fn () =>
          let t1 = textSize "abc" in
          assertEq t1 t1.reset);

        testCaseF "with `shift` fixes width" (fn () =>
          let t = textSize "abc" in
          assertEqF (t <> t.shift).reset.width (SLast {width=6} (SFix {width=6})));
      ());
    ())
