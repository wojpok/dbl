import open Size
import open Lines
import /List
import /Lazy
import /Stream
import Style
import /String

let ~onError () = runtimeError "PrettyPrinter - internal error"

type Layout = Pair Size DocLines

method combine ((x1, y1) : Layout) ((x2, y2) : Layout) =
  (x1.combine x2, y1.combine y2)

method flush ((x, y) : Layout) =
  (x.flush, y.flush)

method reset ((x, y) : Layout) =
  (x.reset, y.reset x.width)

method seq (l1 : Layout) (l2 : Layout) =
  let mkSeq
      {~onError : Unit ->> Unit}
      ((x1, y1) : Layout)
      ((x2, y2) : Layout) =
    (x1.seq x2, y1.seq y2 x1.getAlign)
  let gentle =
    handle
      ~onError = effect _ => None
      return c => Some c
    in mkSeq l1 l2 in
  match gentle with
  | Some c => c
  | None =>
    let ~onError _ = impossible () in
    mkSeq (l1.reset) (l2.reset)
  end

method style ((x, y) : Layout) (sty : Style.Style) = (x, y.style sty)

parameter EY : effect
parameter ~yield : Layout ->[EY] Unit

let topYieldH =
  handler
    effect yield x => x
    return () => ~onError ()
  end

data rec Gen = Gen of (Unit ->[] Option (Pair Layout Gen))
let ungen (Gen f) = f
let emptyGen = Gen (fn _ => None)
let runGen g = ungen g ()
let cons x g = Gen (fn _ => Some (x, g))
let lazyCons (x : Layout) (f : Unit ->[] Gen) =
  Gen (fn _ => Some (x, Gen (fn _ => ungen (f ()) ())))

let genYieldH =
  handler
    effect x / r => lazyCons x r
    return () => emptyGen
  end

let rec genTakeWhile f xs =
  handle ~yield with genYieldH in
    let rec iter gen =
    match runGen gen with
    | Some (x, xs) =>
      if f x then
        (~yield x; iter gen)
    | None => ()
    end
  in
  iter xs

let runGenH f x = handle ~yield / EY with genYieldH in f x

pub data ODoc = ODoc of ({E, ~yield : Layout ->[E] Unit} -> Int ->[E] Unit)

let rec yieldFromGen g =
  match runGen g with
  | Some (x, g) => ~yield x; yieldFromGen g
  | None => ()
  end

pub let text str = ODoc (fn _ =>
  ~yield (textSize str, textLines str))
pub let emptyDoc = text ""

let textLayout str = (textSize str, textLines str)
let spaces n = textLayout (" " ** n)

pub let (<>) {X, method combine : X -> X ->[] X} (x : X) = x.combine
pub let ($$)
    { X
    , method combine : X -> X ->[] X
    , method flush : X ->[] X
    } (x : X) =
  x.flush.combine

pub let paretoSelector
  (poset : Layout -> Layout ->[] Bool)
  (seq : Gen) = 
    let rec iter (mins : List Layout) (seq : Gen)=
      match runGen seq with
      | None => ()
      | Some (x, seq) =>
        match List.findIndex (fn y => poset y x) mins with
        | Some _ => iter mins seq
        | None => ~yield x; (iter (x :: mins) seq)
        end
      end in
    iter [] seq

pub let rec mergeOn {~yield : Layout ->> Unit} sel (xs : Gen) (ys : Gen) =
  rec
    let leftMerge x xs ys =
      match runGen ys with
      | None => ~yield x; yieldFromGen xs
      | Some (y, ys) =>
        if sel x y then
          (~yield x; rightMerge xs y ys)
        else
          (~yield y; leftMerge x xs ys)
      end
    let rightMerge xs y ys =
      match runGen xs with
      | None => ~yield y; yieldFromGen ys
      | Some (x, xs) =>
        if sel x y then
          (~yield x; rightMerge xs y ys)
        else
          (~yield y; leftMerge x xs ys)
      end
  end
  in
  match (runGen xs, runGen ys) with
  | None, None => ()
  | Some (x, xs), None => ~yield x; yieldFromGen xs
  | None, Some (y, ys) => ~yield y; yieldFromGen ys
  | Some (x, xs), Some (y, ys) =>
    if sel x y then
      (~yield x; rightMerge xs y ys)
    else
      (~yield y; leftMerge x xs ys)
  end

pub let rec mergeAllOn sel (xss : List Gen) =
  match xss with
  | [x] => x
  | []  => emptyGen
  | x :: xs =>
    handle ~yield / EY with genYieldH in
      mergeOn sel x (mergeAllOn sel xs)
  end 

pub let bestOn ord poset xss =
  paretoSelector poset (mergeAllOn ord xss)

let maxWidth (w : Size) = w.comp.force.snd

# assumes non-empty input and returns non empty output
pub let quasifilter
    (pred : Layout ->[] Bool)
    (ord : Layout -> Layout ->[] Bool)
    (gen : Gen) =
  let rec iter gen xs yielded =
    match runGen gen with
    | Some (x, gen) =>
      if pred x then
        (~yield x; iter gen [] True)
      else
        iter gen xs yielded
    | None =>
      if not yielded then
        ~yield (List.foldRight1Err
            (fn x y => if ord x y then x else y) xs)
    end
  in
  iter gen [] False

let discardInvalid (w : Int) =
  quasifilter
    (fn s => maxWidth (fst s) <= w)
    (fn x y => maxWidth (fst x) <= maxWidth (fst y))

pub method combine (ODoc xs) (ODoc ys) = ODoc (fn w =>
  # let ds = xs w >.map (fn x =>
  #   (discardInvalid w (ys w >.map (fn y => (x <> y)))))
  # in
  let ys =
    handle
      ~yield = effect x / r => Stream.cons x (Stream.lazyStream r)
      return () => Stream.empty
    in
    ys w
  let xs = 
    handle
      ~yield = effect x / r => x :: r ()
      return () => []
    in
    xs w
  let ds = xs.map (fn x =>
    (handle ~yield / EY with genYieldH in
      discardInvalid w
      (handle ~yield / EY with genYieldH in
          (ys.iter (fn y => ~yield (x <> y))))))
  in
  bestOn
    (fn x y => ord (fst x) (fst y))
    (fn x y => poset (fst x) (fst y))
      ds)

pub let groupingBy (sep : String) (ms : List (Pair Int ODoc)) =
  match ms with
  | [] => emptyDoc
  | ms => ODoc (fn w =>
    let sep = textLayout sep in
    let (mws : List (Pair Int Gen))
      = List.map (fn (x, ODoc d) => (x, runGenH d w)) ms in
    let (init, (_, last)) = List.dropTakeLast mws >.unwrapErr in
    let (hcat : List (Gen))
      = List.map
          (fn x => genTakeWhile (fn l => l.fst.height == 0)
          (snd x)) init 
        + [last] in
    let (vcat : List (Stream.Stream Layout))
      = List.map (fn (i, x) => Stream.map (fn x => spaces i <> x) x) mws in
    let hor = discardInvalid w
      (List.foldRight1
        (fn xs ys => xs >>= (fn x =>
                     ys >>= (fn y =>
                     Stream.singleton (x <> sep <> y))))
        hcat).unwrapErr in
    let ver =
      List.foldRight1
        (fn xs ys =>
          bestOn 
            (fn x y => ord (fst x) (fst y))
            (fn x y => poset (fst x) (fst y))
            ((xs : Stream.Stream _).map (fn x =>
              ys.map (fn y => (x $$ y)))))
        vcat >.unwrapErr
    let ls = bestOn
      (fn x y => ord (fst x) (fst y))
      (fn x y => poset (fst x) (fst y))
      (Stream.fromList [hor, ver]) in
    discardInvalid w ls)
  end

pub method flush (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.flush, y.flush)))

pub method reset (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.reset, y.reset x.width)))

pub method shift {?fill : Char} (ODoc xs) = ODoc (fn w =>
  xs w >.map (fn ((x, y) : Layout) => (x.shift, y.shift {?fill})))

pub method seq {~__line__, ~__file__} (ODoc xs) (ODoc ys) = ODoc (fn w =>
  bestOn
    (fn x y => ord (fst x) (fst y))
    (fn x y => poset (fst x) (fst y))
      (xs w >.map
        (fn (x : Layout) =>
          discardInvalid w (ys w >.map (fn y => x.seq y)))))

pub method style (ODoc xs) (sty : Style.Style) = ODoc (fn w =>
  xs w >. map (fn (l : Layout) => l.style sty))

pub let (vsep : ODoc) = ODoc (fn _ =>
  Stream.singleton (textSize " | ", vsep))

pub let generate {?width : Int} (ODoc xs) =
  let width = width.unwrapOr 80 in
  match xs width >.uncons with
  | None => runtimeError "Layout selection error"
  | Some (layout, _) =>
    let (_, lines) = layout.reset in
    let lines = lines.force in
    (unlines width lines : String)
  end

pub let generateDebug width (ODoc xs) =
  runtimeError "DEL"
