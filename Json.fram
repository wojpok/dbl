import open Parser
import open Format

data rec Json =
  | JNum    of Int
  | JString of String
  | JBool   of Bool
  | JNull
  | JArray  of List Json
  | JDict   of List (Pair String Json)

method rec format {?fmt : Unit} (self : Json) =
  match self with
  | JNum n => n.format
  | JString s => s.format
  | JBool b => b.format {fmt=BoolFmt{true="true", false="false"}}
  | JNull => "null"
  | JArray xs => xs.format
  | JDict xs =>
    let rec iter xs =
      match (xs : List (Pair String Json)) with
      | [] => "}"
      | [(k, v)] => "\{k}: \{v}}"
      | (k, v) :: xs =>
        "\{k}: \{v}, " + iter xs
      end in
      "{" + iter xs
  end

let jNumber = parseNumber.lexeme.map (fn x => JNum x)
let jNull   = parseKeyword "null"  >.lexeme >.val JNull
let jBool   = parseKeyword "true"  >.lexeme >.val (JBool True)
         <|> (parseKeyword "false" >.lexeme >.val (JBool False))
                
let stringParser = 
  char '"'
  >.seq (isChar (fn (x : Char) => x != '"') 
    >.many >.map (fn xs => charListToStr xs))
  >.before (char '"' >.lexeme)

let jString = JString <$> stringParser

rec
  let jValue () = 
    parseChoice [jNumber, jNull, jBool, jString, delay jArray, delay jDict]
    >.msg "Expected json value"

  let jArray () =
    char '[' >.lexeme
    >.seq (delay jValue >.sepBy (char ',' >.lexeme) >.map JArray)
    >.before (char ']' >.lexeme)

  let pair a b = (a, b)

  let jDict () =
    (char '{' >.lexeme)
    *> ((pair <$> (stringParser <* (char ':' >.lexeme))
              <*> (delay jValue)) >.sepBy (char ',' >.lexeme) >.map JDict)
    <* (char '}' >.lexeme)
end

let pe (p : SP _ _) = 
  let _ = char ':' >.runP p
  let _ = char ' ' >.many >.runP p
  let _ = parseNumber.runP p in
  # let () = p.fail "" in
  JNum 10

# let full p = let res = jArray.runP p in res

let json = "
{\"menu\": {
  \"id\": \"file\",
  \"value\": \"File\",
  \"popup\": {
    \"menuitem\": [
      {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},
      {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},
      {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}
    ]
  }
}}
"

let tparser = 
  parseChoice 
    [ parseKeyword "true"  >.val True  >.msg "true"
    , parseKeyword "false" >.val False >.msg "false"
    ] >.msg "true or false"

let res = handle p with runParser json in (empty.lexeme.seq (delay jValue) >.runP p)

#let res = handle p with runParser "" in tparser.runP p

let _ = printStrLn res.format

